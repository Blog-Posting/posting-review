<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>자바스크립트 코딩의 기술(시리즈 2 - 배열로 데이터 컬렉션을 관리하다)</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-light">
        <h1 id="자바스크립트-코딩의-기술시리즈-2---배열로-데이터-컬렉션을-관리하다">자바스크립트 코딩의 기술(시리즈 2 - 배열로 데이터 컬렉션을 관리하다)</h1>
<ul>
<li>자바스크립크 코딩의 기술 책을 읽고 복습 겸 정리하는 포스팅이다.</li>
<li>시리즈 1이 시작이며 시리즈 몇까지는 갈지는 진행하면서 가늠잡아 보겠다.</li>
</ul>
<h2 id="배열로-유연한-컬렉션을-생성하라tip5">배열로 유연한 컬렉션을 생성하라(TIP5)</h2>
<ul>
<li>자바스크립트에는 데이터 컬렉션을 다루는 구조로 배열, 객체 이렇게 두가지가 있었다.</li>
<li>모던 자바스크립트에서 맵(Map), 세트(Set), 위크맵(WeakMap), 위크셋(WeakSet), 객체, 배열을 사용할 수 있다.</li>
<li>컬렉션을 선택할 때는 정보로 어떤 작업을 할지 생각해봐야 된다.</li>
<li>대부분 배열을 사용하며 배열을 사용하지 않아도 배열에 적용되는 개념을 빌리게 된다.</li>
<li>배열의 순서가 기술적으로 보장되지 않지만 대부분 상황에서 동작한다고 생각하면 된다.(<a href="https://stackoverflow.com/questions/34955787/is-a-javascript-array-order-guaranteed">https://stackoverflow.com/questions/34955787/is-a-javascript-array-order-guaranteed</a>)</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> team = [<span class="hljs-string">'Lee'</span>,<span class="hljs-string">'Kim'</span>,<span class="hljs-string">'Son'</span>];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alphabetizeTeam</span>(<span class="hljs-params">team</span>) </span>{
  <span class="hljs-keyword">return</span> [...team].sort();
}
alphabetizeTeam(team);(<span class="hljs-number">3</span>) <span class="hljs-comment">// ["Kim", "Lee", "Son"]</span>
</div></code></pre>
<ul>
<li><code>map(), filter(), reduce()</code>등의 배열 메서드를 이용하면 코드 한줄로 정보를 변경하거나 갱신할 수 있다.
<ul>
<li>map() 메서드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환합니다.</li>
<li>filter() 메서드는 주어진 함수의 테스트를 통과하는 모든 요소를 모아 새로운 배열로 반환합니다.</li>
<li>reduce() 메서드는 배열의 각 요소에 대해 주어진 리듀서(reducer) 함수를 실행하고, 하나의 결과값을 반환합니다.</li>
</ul>
</li>
</ul>
<hr>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> staff = [{
  <span class="hljs-attr">name</span>: <span class="hljs-string">'duckhee'</span>, 
  <span class="hljs-attr">position</span>: <span class="hljs-string">'developer'</span>,
},
{
  <span class="hljs-attr">name</span>: <span class="hljs-string">'rain'</span>, 
  <span class="hljs-attr">position</span>: <span class="hljs-string">'musician'</span>
}]

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMusician</span>(<span class="hljs-params">staff</span>) </span>{
  <span class="hljs-keyword">return</span> staff.filter(<span class="hljs-function"><span class="hljs-params">member</span> =&gt;</span> member.position === <span class="hljs-string">'musician'</span>)
}
getMusician(staff);  <span class="hljs-comment">// [ {name: "rain", position: "musician"} ]</span>
</div></code></pre>
<ul>
<li>객체를 순회하려면 먼저 <code>Object.keys()</code>를 실행해서 객체의 키를 배열에 담은 후 생성한 배열을 이용해 순회</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> game1 = {
  <span class="hljs-attr">player</span>: <span class="hljs-string">'Lee'</span>,
  <span class="hljs-attr">goal</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">pass</span>: <span class="hljs-number">101</span>,
  <span class="hljs-attr">errors</span>: <span class="hljs-number">0</span>
}
<span class="hljs-keyword">const</span> game2 = {
  <span class="hljs-attr">player</span>: <span class="hljs-string">'Son'</span>,
  <span class="hljs-attr">goal</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">pass</span>: <span class="hljs-number">205</span>,
  <span class="hljs-attr">errors</span>: <span class="hljs-number">1</span>
}

<span class="hljs-keyword">const</span> total = {}
<span class="hljs-keyword">const</span> stats = <span class="hljs-built_in">Object</span>.keys(game1);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;  i &lt; stats.length; i++) {
  <span class="hljs-keyword">const</span> stat = stats[i];
  <span class="hljs-keyword">if</span> (stat !== <span class="hljs-string">'player'</span>) {
    total[stat] = game1[stat] + game2[stat]
  }
}

consoel.log(total
<span class="hljs-comment">// {goal: 3, pass: 306, errors: 1}</span>
</div></code></pre>
<ul>
<li>배열에 이터러블(<code>iterable</code>)이 내장되어 있다. 간단히 말해 컬렉션의 현재 위치를 알고 있는 상태에서 컬렉션의 항목을 한 번에 하나씩 처리하는 방법이다. (<a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Iteration_protocols">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Iteration_protocols</a>)</li>
<li>배열을 특별한 컬렉션으로 쉽게 변환하거나 다시 배열로 만들 수 있다.</li>
<li>키-값 저장소와 동일한 개념을 2차원 배열로 설명할 수 있다. 내부의 배열은 두 가지 항목만 갖는다. 첫번째 항목은 키, 두번째 항목은 값이다.</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> dog = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Binhee'</span>,
  <span class="hljs-attr">color</span>: <span class="hljs-string">'brown'</span>,
};
dog.name; <span class="hljs-comment">// Binhee</span>
</div></code></pre>
<ul>
<li>다음 코드는 객체를 키-값 쌍을 모은 배열로 바꿨다. 실제로 키-값 쌍을 사용해 맵 객체와 배열간의 데이터를 변화 한다.(<code>Object.entries()</code> - (<a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/entries</a>))</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> dogPair = [[<span class="hljs-string">'name'</span>,<span class="hljs-string">'Binhee'</span>],[<span class="hljs-string">'color'</span>,<span class="hljs-string">'brown'</span>]];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params">dog</span>) </span>{
  <span class="hljs-keyword">return</span> dog.find(<span class="hljs-function"><span class="hljs-params">attribute</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> attribute[<span class="hljs-number">0</span>] === <span class="hljs-string">'name'</span>;
  })[<span class="hljs-number">1</span>];
}
</div></code></pre>
<h2 id="incdlues존재-여부를-확인하라tip6"><code>incdlues()</code>존재 여부를 확인하라(TIP6)</h2>
<ul>
<li>기존 배열에서 특정 문자열을 포함하고 있는 확인하려면 문자열의 위치를 찾았다. 즉, <code>indexOf</code>를 사용하여 문자열이 있으면 해당 <code>index</code> 반환, 없으면 <code>-1</code>를 반환했다. 근데 이때 만약 <code>0</code>번째에서 찾아지면 if 문에서 <code>false</code> 를 반환하므로 문제가 생긴다.</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> sections = [<span class="hljs-string">'shipping'</span>];

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayShipping</span>(<span class="hljs-params">sections</span>) </span>{
  <span class="hljs-keyword">if</span> (sections.indexOf(<span class="hljs-string">'shipping'</span>)) { <span class="hljs-comment">// 0 를 반환하므로 false로 실행된다.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
<span class="hljs-comment">// false</span>

보완코드
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayShipping</span>(<span class="hljs-params">sections</span>) </span>{
  <span class="hljs-keyword">return</span> sections.indexOf(<span class="hljs-string">'shipping'</span>) &gt; <span class="hljs-number">-1</span>
}
<span class="hljs-comment">// true</span>

includes() 를 사용한 코드
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayShipping</span>(<span class="hljs-params">sections</span>) </span>{
  <span class="hljs-keyword">return</span> sections.includes(<span class="hljs-string">'shipping'</span>)
}
</div></code></pre>
<ul>
<li><code>includes()</code> 를 사용하면 -1를 사용해 비교하는 번거로운 로직을 안써도 된다.</li>
</ul>
<h2 id="펼침-연산자로-배열을-본떠라tip7">펼침 연산자로 배열을 본떠라(TIP7)</h2>
<ul>
<li>펼침 연산자(<code>spread operator</code>)(<a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_syntax">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_syntax</a>) 는 마침표 3개(<code>...</code>)를 사용한다. 배열에 포함된 항목을 목록으로 바꿔준다.</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> cart = [<span class="hljs-string">'Nmaing and Necessity'</span>, <span class="hljs-string">'Alice in Wonderland'</span>];
...cart <span class="hljs-comment">// 단독으로 사용할 경우 에러, 정보를 어디든 펼쳐 넣어야 합니다.</span>
<span class="hljs-keyword">const</span> copyCart = [...cart]; 
<span class="hljs-comment">// ["Nmaing and Necessity", "Alice in Wonderland"]</span>
</div></code></pre>
<ul>
<li>배열에서 항목을 제거할 경우</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-comment">// removable에 해당 요소를 넣고 삭제할 요소 빼고 배열을 만든다.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeItem</span>(<span class="hljs-params">items, removable</span>) </span>{
  <span class="hljs-keyword">const</span> updated = [];
  <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; items.length; i++) {
    <span class="hljs-keyword">if</span> (items[i] !== removable) {
      updated.push(items[i])
    }
  }
  <span class="hljs-keyword">return</span> updated;
}
</div></code></pre>
<ul>
<li>위에 코드는 잘 작동하지만 단순하게 변경해보자.</li>
<li><code>splice()</code> 사용한 코드</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeItem</span>(<span class="hljs-params">items, removable</span>) </span>{
  <span class="hljs-keyword">const</span> index = items.indexOf(removable);
  items.splice(index, <span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> items;
}
</div></code></pre>
<ul>
<li>문제는 <code>splice</code>는 원본 데이터를 조작한다.</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> fruits = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'melon'</span>]
<span class="hljs-keyword">const</span> isNotRedColorFruits = removeItem(fruits, <span class="hljs-string">'apple'</span>) <span class="hljs-comment">// ['banana', 'melon']</span>
<span class="hljs-comment">// fruits도 ['banana', 'melon']</span>
<span class="hljs-keyword">const</span> isNotYellowColorFruits = removeItem(fruits, <span class="hljs-string">'banana'</span>) <span class="hljs-comment">// ['melon']</span>
<span class="hljs-comment">// fruits도 ['melon']</span>
</div></code></pre>
<ul>
<li>원본 <code>fruits</code> 배열이 변경 된다. <code>const</code>를 사용해 만들어서 변경되지 않을거라고 생각되었지만 항상 그렇지 않다.</li>
<li><code>slice</code>를 사용해보자. 원본 배열을 변경하지 않고 배열의 일부를 반환한다.</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeItem</span>(<span class="hljs-params">items, removable</span>) </span>{
  <span class="hljs-keyword">const</span> index = items.indexOf(removable);
  <span class="hljs-keyword">return</span> items.slice(<span class="hljs-number">0</span>, index).concat(items.slice(index + <span class="hljs-number">1</span>));
}
</div></code></pre>
<ul>
<li>작동은 잘되지만 <code>slice</code>,<code>concat</code>를 사용해 어떤 값이 반환되는지 직관적으로 알 수 없다.</li>
<li>이럴때 펼침 연산자를 사용한다.</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeItem</span>(<span class="hljs-params">items, removable</span>) </span>{
  <span class="hljs-keyword">const</span> index = items.indexOf(removable);
  <span class="hljs-keyword">return</span> [...items.slice(<span class="hljs-number">0</span>, index), ...items.slice(index + <span class="hljs-number">1</span>)];
}
</div></code></pre>
<ul>
<li>위에 코드보다 간결하고 재사용할 수 있으며 예측이 가능하다.(전 비슷한듯....)</li>
<li>또한 펼침 연산자를 사용하면 배열의 항목을 쉽게 꺼내 인수 목록을 쉽게 사용이 가능하다.</li>
<li><a href="https://amagrammer91.tistory.com/9">인수, 인자 차이</a></li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> book = [<span class="hljs-string">'Reasons and Persons'</span>, <span class="hljs-string">'Derek Parfit'</span>, <span class="hljs-number">19.99</span>];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatBook</span>(<span class="hljs-params">title, author, price</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${title}</span> by <span class="hljs-subst">${author}</span> $<span class="hljs-subst">${price}</span>`</span>;
}

formatBook(book[<span class="hljs-number">0</span>], book[<span class="hljs-number">1</span>], book[<span class="hljs-number">2</span>]) <span class="hljs-comment">// 확장성이 없고 인수값이 늘어나면 또 작성해야된다.</span>
formatBook(...book) <span class="hljs-comment">// 나중에 인수가 추가되도 고치지 않아도 된다.</span>
</div></code></pre>
<h2 id="push-메서드-대신-펼침-연산자로-원본-변경을-피하라-tip8"><code>push()</code> 메서드 대신 펼침 연산자로 원본 변경을 피하라 (TIP8)</h2>
<ul>
<li>역시 원본 배열 조작을 피하는 방법을 살펴보자.</li>
<li>예측하지 못한 조작은 심각한 버그를 발생시키므로 가능하며 조작은 피하는게 좋고, 또한 모던자바스크립트의 대부분 함수형 프로그래밍 형식을 취하기떄문에 부수효과와 조작이 없는 코드를 작성해야 한다.(함수형 프로그래밍을 공부하자)</li>
<li><code>push()</code> 메서드를 통해 알아보자. <code>push()</code> 메서드는 새로운 항목을 배열 뒤에 추가해 원본 배열을 변경한다.</li>
<li>장바구니 상품 목록을 받아서 내용을 요약하는 간단한 함수 코드이다.
<ol>
<li>할인 금액 확인</li>
<li>할인 상품이 2개 이상인지 확인
<ol>
<li>2개 이상일때 오류 객체 반환</li>
</ol>
</li>
<li>오류가 없고 상품이 3개이상 구매 시 사은품 증정</li>
</ol>
</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 카트 정의</span>
<span class="hljs-keyword">const</span> cart = [{
    <span class="hljs-attr">name</span>: <span class="hljs-string">'The Foundation Triology'</span>,
    <span class="hljs-attr">price</span>: <span class="hljs-number">19.99</span>,
    <span class="hljs-attr">discount</span>: <span class="hljs-literal">false</span>,
  },{
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Godel, Escher, Bach'</span>,
    <span class="hljs-attr">price</span>: <span class="hljs-number">15.99</span>,
    <span class="hljs-attr">discount</span>: <span class="hljs-literal">false</span>,
  },{
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Red Mars'</span>,
    <span class="hljs-attr">price</span>: <span class="hljs-number">5.99</span>,
    <span class="hljs-attr">discount</span>: <span class="hljs-literal">true</span>,
  }
];

<span class="hljs-comment">// 사은품 정의</span>
<span class="hljs-keyword">const</span> reward = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Guide to Science Fiction'</span>,
  <span class="hljs-attr">discount</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">price</span>: <span class="hljs-number">0</span>,
}

<span class="hljs-comment">// 사은품 증정</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addFreeGift</span>(<span class="hljs-params">cart</span>) </span>{
  <span class="hljs-keyword">if</span> (cart.length &gt; <span class="hljs-number">2</span>) {
    cart.push(reward);
    <span class="hljs-keyword">return</span> cart;
  }
  <span class="hljs-keyword">return</span> cart;
}

<span class="hljs-comment">// 카트 정리 - 기존</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">summerizeCart</span>(<span class="hljs-params">cart</span>) </span>{
  <span class="hljs-comment">// 할인중인 상품이 있는지 확인</span>
  <span class="hljs-keyword">const</span> discountable = cart.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.discount);

  <span class="hljs-comment">// 할인 상품이 2개 이상인지 확인</span>
  <span class="hljs-keyword">if</span>(discountable.length &gt; <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">error</span>: <span class="hljs-string">'할인 상품은 하나만 주문할 수 있습니다.'</span>
    }
  }

  <span class="hljs-comment">// 오류가 안나니 사은품 증정</span>
  <span class="hljs-keyword">const</span> cartWithReward = addFreeGift(cart);

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">discounts</span>: discountable.length,
    <span class="hljs-attr">items</span>: cartWithReward.length,
    <span class="hljs-attr">cart</span>: cartWithReward
  }
}
</div></code></pre>
<ul>
<li>만약 새로운 개발자나 아무개나 코드 정리하고 싶어서 모든 변수 할당을 최상위로 옮기려고 한다면?</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 카트 정리 - 아무개 수정</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">summerizeCart</span>(<span class="hljs-params">cart</span>) </span>{
  <span class="hljs-comment">// 할인중인 상품 체크 안하고 카트에 바로 사은품 증정 로직</span>
  <span class="hljs-comment">// push가 있으므로 원본 cart 조작</span>
  <span class="hljs-keyword">const</span> cartWithReward = addFreeGift(cart);
  <span class="hljs-comment">// 조작된 cart로 할인중인 상품이 있는지 확인</span>
  <span class="hljs-keyword">const</span> discountable = cart.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.discount); <span class="hljs-comment">// 사은품이 discountable 하니 사은품 기본으로 포함해서 반환</span>

  <span class="hljs-comment">// 할인 상품이 2개 이상인지 확인</span>
  <span class="hljs-comment">// 사은품 제외하고 할인 상품이 1개라도 있으면 2개가 되서 오류!</span>
  <span class="hljs-keyword">if</span>(discountable.length &gt; <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">error</span>: <span class="hljs-string">'할인 상품은 하나만 주문할 수 있습니다.'</span>
    }
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">discounts</span>: discountable.length,
    <span class="hljs-attr">items</span>: cartWithReward.length,
    <span class="hljs-attr">cart</span>: cartWithReward
  }
}
</div></code></pre>
<ul>
<li>상품 3개이상 선택하고, 그 중 하나가 할인 상품이면 모든 고객에서 오류 발생한다.</li>
<li>예제를 통해 살펴본 문제의 대부분은 분리된 함수에서 의도치 않게 원본을 조작 한것이 원인이다.</li>
<li>부수효과가 없는 함수를 순수함수(pure function)라고 하며, 순수함수를 만들기 위해 노력해야 한다.</li>
<li>위에 코드를 펼침 연산자를 이용해 수정해보자.</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addFreeGift</span>(<span class="hljs-params">card</span>) </span>{
  <span class="hljs-keyword">if</span> (cart.length &gt; <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> [...cart, reward];
  }
  <span class="hljs-keyword">return</span> cart;
}
</div></code></pre>
<ul>
<li>이렇게 하면 <code>discountable</code> 할당할때 <code>cart</code>가 변경되지 않은 원본 배열을 사용하므로 정상적인 코드가 된다.</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> titles = [<span class="hljs-string">'Moby Dick'</span>, <span class="hljs-string">'White Teeth'</span>];
<span class="hljs-keyword">const</span> moreTitles = [...titles, <span class="hljs-string">'The Conscious Mind'</span>];
<span class="hljs-comment">// ['Moby Dick', 'White Teeth', 'The Conscious Mind'];</span>
</div></code></pre>
<ul>
<li>시작 부분에 새로운 항목울 추가하려면?</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 배열 앞에 추가하기</span>
<span class="hljs-keyword">const</span> titles = [<span class="hljs-string">'Moby Dick'</span>, <span class="hljs-string">'White Teeth'</span>];
titles.unshift(<span class="hljs-string">'The Conscious Mind'</span>)
<span class="hljs-keyword">const</span> moreTitles = [<span class="hljs-string">'Moby Dick'</span>, <span class="hljs-string">'White Teeth'</span>];
<span class="hljs-keyword">const</span> evenMoreTitles = [<span class="hljs-string">'The Conscious Mind'</span>, ...moreTitles ];

<span class="hljs-comment">// 복사하기</span>
<span class="hljs-keyword">const</span> toCopy = [<span class="hljs-string">'Moby Dick'</span>, <span class="hljs-string">'White Teeth'</span>];
<span class="hljs-keyword">const</span> copied = toCopy.slice();
<span class="hljs-keyword">const</span> moreCopies = [<span class="hljs-string">'Moby Dick'</span>, <span class="hljs-string">'White Teeth'</span>];
<span class="hljs-keyword">const</span> moreCopied = [...moreCopies];
</div></code></pre>
<ul>
<li><code>slice()</code> 메서드로 새울 배열을 생성할 수 있지만 기억이 나지 않을 수도 있고, 중괄호를 보면 어떤 값이 반환되는데 확실히 알 수 있다.</li>
</ul>
<h2 id="펼침-연산자로-정렬에-의한-혼란을-피하라-tip9">펼침 연산자로 정렬에 의한 혼란을 피하라 (TIP9)</h2>
<ul>
<li>이번 팁에서 배열을 여러번 정렬해도 항상 같은 결과가 나오게 펼침 연산자를 사용하는 방법을 알아보자.</li>
<li>직원 정보가 담긴 배열을 이름 또는 근속연수로 정렬하는 코드이다.</li>
</ul>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 직원 정의</span>
<span class="hljs-keyword">const</span> staff = [
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Joe'</span>,
    <span class="hljs-attr">years</span>: <span class="hljs-number">10</span>,
  },
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Thoe'</span>,
    <span class="hljs-attr">years</span>: <span class="hljs-number">5</span>
  },
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Dyan'</span>,
    <span class="hljs-attr">years</span>: <span class="hljs-number">10</span>,
  },
];

<span class="hljs-comment">// 정렬 함수</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortByYears</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">if</span> (a.years === b.years) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">return</span> a.years - b.years;
}

<span class="hljs-keyword">const</span> sortByName = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (a.name === b.name) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">return</span> b.name &gt; a.name ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
}
</div></code></pre>
<ul>
<li>
<p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"><code>sort()</code> 메서드에 관한 내용은 문서</a></p>
<ul>
<li>compareFunction(a, b)이 0보다 작은 경우 a를 b보다 낮은 색인으로 정렬합니다. 즉, a가 먼저옵니다.</li>
<li>compareFunction(a, b)이 0을 반환하면 a와 b를 서로에 대해 변경하지 않고 모든 다른 요소에 대해 정렬합니다. 참고 : ECMAscript 표준은 이러한 동작을 보장하지 않으므로 모든 브라우저(예 : Mozilla 버전은 적어도 2003 년 이후 버전 임)가 이를 존중하지는 않습니다.</li>
<li>compareFunction(a, b)이 0보다 큰 경우, b를 a보다 낮은 인덱스로 소트합니다.</li>
<li>compareFunction(a, b)은 요소 a와 b의 특정 쌍이 두 개의 인수로 주어질 때 항상 동일한 값을 반환해야합니다. 일치하지 않는 결과가 반환되면 정렬 순서는 정의되지 않습니다.</li>
</ul>
</li>
<li>
<p>맨 처음 정렬을 근속 연수로 했을 경우이다.</p>
</li>
</ul>
<pre><code class="language-javascript"><div>staff.sort(sortByYears);

<span class="hljs-comment">// [</span>
<span class="hljs-comment">//   {name: "Thoe", years: 5} {name: "Joe", years: 10} {name: "Dyan", years: 10}</span>
<span class="hljs-comment">// ]</span>

<span class="hljs-comment">// 이때 staff도 위와 같은 변경된 배열과 같다.</span>
</div></code></pre>
<ul>
<li>맨 처음 정렬을 이제 사용자 이름순으로 정렬한 경우이다.</li>
</ul>
<pre><code class="language-javascript"><div>staff.sort(sortByName);

<span class="hljs-comment">//   {name: "Dyan", years: 10} {name: "Joe", years: 10} {name: "Theo", years: 5}</span>
</div></code></pre>
<ul>
<li>이제 사용자 이름순 -&gt; 근속 년수로 정렬했을 경우이다.</li>
<li>처음 근속 연수로 정렬했을때와 같은 순서로 기대했는데 결과는 다르다.</li>
</ul>
<pre><code class="language-javascript"><div>staff.sort(sortByName);
staff.sort(sortByYears);

<span class="hljs-comment">//   {name: "Theo", years: 5} {name: "Dyan", years: 10} {name: "Joe", years: 10}</span>
</div></code></pre>
<ul>
<li>만약 수백명의 직원리스트가 있어 정렬을 하는데 정렬할때마다 순서가 달라지게 되면 신뢰를 잃을 것입니다.</li>
<li>이 부분을 수정하기 위해서 간단합니다. 배열을 조작하지 않으면 됩니다. 사본을 만들고 사본을 조작하자.</li>
</ul>
<pre><code class="language-javascript"><div>[...staff].sort(sortByYears);

<span class="hljs-comment">//   {name: "Thoe", years: 5} {name: "Joe", years: 10} {name: "Dyan", years: 10}</span>
</div></code></pre>

    </body>
    </html>