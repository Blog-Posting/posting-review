# 생성자 대신 정적 팩토리 메소드를 고려하라.

## 1. 개요

클라이언트가 클래스의 인스턴스를 얻는 수단은 다음과 같이 두 가지로 나눌 수 있다.
* public 생성자
```java
public Book(){}
```
* 정적 팩터리 메서드
```java
public static Book createBook(){
    return instance();
}
```
일반적인 public생성자에 비해 정적 팩터리 메서드는 다양한 장점을 가지고 있다.    
그 장점이 무엇인지 알아보자.

## 2. 정적 팩터리 메서드의 장점
---
### (1). 이름을 가질 수 있다.
* 정적 팩터리 메소드는 '메소드'이기 때문에 이름을 가질 수 있다.   
* 그 이름을 통해 해당 정적 메서드가 어떤 특징을 갖는지, `어떤 인스턴스를 반환하는지 명시적으로 표현`할 수 있다.

---

### (2). 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.

* public 생성자는 new로 호출하게 되어 무조건 새롭게 인스턴스를 생성해야 한다.
* 반면 정적 팩터리 메소드는 `기존에 존재하는 인스턴스를 반환`할 수 있기 때문에 반드시 새로 생성할 필요가 없다.
* 이처럼 미리 인스턴스를 생성해 놓고, 필요할 때마다 이를 가져다 쓰는 방식을 인스턴스 캐싱이라 한다.
* 인스턴스 캐싱 덕분에 [불변 클래스](https://rockjoon.tistory.com/42?category=843526)의 경우 객체 생성의 비용을 감소시켜 성능을 끌어올릴 수 있다.   
* 단순히 인스턴스를 반환하는 것에서 더 나아가, 인스턴스의 생명주기를 관리하는 역할을 수행하기도 한다.(싱글턴 패턴, 인스턴스화 불가, 불변 클래스 등등...) 

---
### (3). 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.

다음은 자바의 표준 API java.util.Collections 의 정적 팩토리 메소드 unmodifiableList의 모습이다.
```java
public static <T> List<T> unmodifiableList(List<? extends T> list) {
        return (list instanceof RandomAccess ?
                new UnmodifiableRandomAccessList<>(list) :
                new UnmodifiableList<>(list));
}
```
* 위의 `메소드의 반환 타입은 List이지만 실제 반환하는 인스턴스는 List의 하위 객체`이다.
* 자바의 Collections 클래스에서는 위와 같은 유틸리티 기능(수정 불가 객체, 동시성 처리 객체 등)이 추가된 45 개의 구현체를 제공한다.
* 이럴 경우의 장점은, 사용자들이 `Collections 클래스만 알고 있으면 45개의 구현체들에 접근`할 수 있다는 것이다.
* 이해를 돕기 위해 이러한 구현체들이 정적 팩토리 메소드가 아닌 일반적인 public 생성자 방식으로 구현되었다고 가정해 보자.
* 사용자들은 45개의 구현체들의 클래스를 일일이 알고 있어야 하고, 이러한 API의 규모는 지나치게 방대해질 것이다.
* 따라서 정적 팩토리 메서드가 사용된 API는 규모를 작게 유지할 수 있다.
---
### (4). 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
* 위에서 보았던 정적 팩토리 메서드 unmodifiableList를 다시 한번 살펴 보자.
* 이 메서드는 `파라미터인 'list'의 타입에 따라` 반환 타입이 달라 진다.
* 이처럼 파라미터에 따라 메소드 내부에서 반환 타입을 달리할 수 있고, 이는 `사용자가 내부의 구현에 대해 알 필요 없이` 원하는 반환 값을 전달 받을 수 있다는 장점이 있다.
* 또한 반환 타입이 추가 되더라도 외부의 변화 없이 반환 타입을 수정할 수 있다.
---

## 3. 정적 팩터리 메서드의 단점
---       

### (1). 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
* 상속을 위해서는 하위 클래스에서 사용할 수 있는 생성자가 필요하다.
* private 생성자를 통해 외부 생성을 막고, 정적 팩터리 메서드만을 사용하여 인스턴스를 반환할 경우, 하위 클래스를 만들 수 없다.
* 하지만 이러한 특성은 해당 클래스를 불변 타입 또는 컴포지션 스타일로 만들 수 있다는 장점이 되기도 한다.

### (2) 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
* 생성자는 이름이 클래스의 이름과 같아서 명확히 알 수 있다.
* 하지만 정적 팩터리 메서드는 다른 메서드와 섞여 찾기 어려울 수 있다.

## 4. 정적 팩터리 메서드의 네이밍
정적 팩터리 메서드는 찾기 어렵다는 단점 때문에, 일반적으로 쓰이는 네이밍 방식들이 있다.     
그 내용은 다음과 같다.

* from : 매개변수를 하나 받아, 해당 타입의 인스턴스를 반환하는 형변환 메서드
```java
// instant 타입을 Date로 변환하여 반환
Date d = Date.from(instant);
```
* of : 매개변수를 여러개 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
```java
// 파라미터로 전달 받은 타입의 Enum을 담은 Set을 반환
Set<Rank> faceCards = Enumset.of(JACK, QUEEN, KING);
```
* valueOf : from과 of의 더 자세한 버전
* instance 혹은 getInstance : 인스턴스를 반환, 그러나 같은 인스턴스임을 보장하지는 않음.
* create 혹은 newInstance : 새로운 인스턴스 생성하여 반환
* getXXX : getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 사용.
```java
// Files 클래스에서 FileStore의 인스턴스를 반환
FileStore fs = Files.getFileStore(path);
```
* newXXX : newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 사용.
```java
// Files 클래스에서 BufferedReader를 반환
BufferedReader br = Files.newBufferedReader(path);
```
* xxx : getXXX과 newXXX의 간결한 버전
```java
List<Complaint> litany = Collections.list(legacyListany);
```